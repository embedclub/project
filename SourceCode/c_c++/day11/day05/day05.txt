复习：
1.构造函数
格式：
  class 类名
  {
     类名(形参表)
     {
        构造函数体;
     }
  };

注意：
  (1)当创建对象时，会自动调用构造函数进行初始化，给成员变量初始化
  (2)如果一个类中没有自定义构造函数，那么系统会自动提供一个无参构造函数(缺省构造函数/默认构造函数);一旦有自定义构造函数，那么系统不再提供无参的构造函数
  (3)无参构造函数未必真的没有参数，而是可以用无参的形式调用

2.初始化列表
2.1 格式
  class 类名
  {
     类名(形参表):成员变量名(形参名),...
     {
         构造函数体;
     }  
  };

2.2 声明、定义、初始化
  声明：类类型的定义中
  定义：创建对象时
  初始化：自动调用构造函数按照初始化列表的规则进行初始化

执行流程：
   创建对象 -> 分配成员变量的内存
-> 调用构造函数按照初始化列表的规则进行初始化 -> 执行构造函数体;

2.3 初始化列表的必要性
(1)类中有常量型和引用型成员变量时，必须通过构造函数和初始化列表的形式进行初始化
(2)在子类中显式地指定基类部分的构造

3.this指针
3.1 概念
  一般而言，对于普通成员函数来说，该指针指向的调用对象的地址;对于构造函数函数来说，该指针指向正在构造的对象

注意：
   对于普通函数和构造函数来说，隐含一个实参：this指针，存储调用对象/正在构造对象的 地址

3.2 this指针的使用场合
(1)用于构造函数中区分与形参名相同的成员变量名，初始化列表不存在此问题
(2)this指针用于返回自引用的场合
(3)用于函数的参数，实现对象间的交互

4.const对象和const成员函数
(1)const修饰的成员函数，叫做常函数，表示this指针为const类型，避免成员变量发生意外修改
(2)const修饰的成员函数和非const修饰的普通成员函数之间构成重载，对于const类型的 对象/指针/引用 只能调用常函数,而对于非const类型的 对象/指针/引用 优先调用非const类型的函数
(3)可以使用mutable修饰成员变量，该成员变量可以在常函数中被修改

5.支持自定义类型转换的构造函数
在目标类型中定义如下形式的函数：
   目标类型::目标类型(const 源类型& 对象){}

   实现从源类型到目标类型的隐式类型转换

注意：
   使用explicit关键修饰构造函数，表示只能使用显式类型转换，而不能发生隐式类型转换

作业:
   
----------------------------------
今天内容：
   (1)析构函数
   (2)拷贝构造和拷贝赋值
   (3)静态成员
   (4)成员指针
   (5)输入输出运算符重载

1.析构函数
   当一个对象被创建时，自动调用构造函数进行初始化
   当一个对象被销毁时，自动调用析构函数进行资源的回收

1.1 格式
  class 类名
  {
     ~类名(void)
     {
        //析构函数体;
     }
  };
  针对构造函数和析构函数 叫做构造器和析构器

注意：
   对于全局变量/局部变量/块变量，当生命周期结束时自动调用析构函数;而对于堆区的对象来说，当delete时会自动调用析构函数

1.2 缺省析构函数
(1)对于未定义析构函数的类，系统会自动提供一个缺省析构函数，该析构函数会调用成员以及基类的析构函数
(2)对于动态分配的资源，必须通过自定义析构函数进行释放，当然所释放的资源不仅仅包括动态内存，还包括文件的关闭，socket的关闭等等

2.拷贝构造和拷贝赋值运算符
2.1 拷贝构造函数
(1)语法格式
   class 类名
   {
      类名(const 类名& 变量名)
      {
         拷贝构造函数体;
      }
   };  

(2)调用拷贝构造的一般形式
    Student{};
    Student s;
    Student s2(s); //调用拷贝构造
    Student s3 = s; //同上
    Student* ps = new Student    (s);//同上

注意：
   (1)类中没有自定义拷贝构造函数时，系统自动提供一个缺省拷贝构造函数
   (2)缺省拷贝构造函数就是按照字节复制一份和拷贝源一模一样的副本
   (3)缺省拷贝构造函数的拷贝方式往往不能实现对象间的深拷贝，这时就需要自定义拷贝构造函数，以获得真正意义上的副本
   (4)拷贝构造函数的调用时机
      a.用同类型的对象初始化
      b.函数调用传递对象型参数
      c.函数返回对象(受编译器影响)

2.2 拷贝赋值运算符函数
如：
    Student s;
    Student s2;
    s2 = s;  //进行拷贝赋值
    => s2.operator=(s);

(1)格式
  Student& operator=(const Student& s)
  {
      //拷贝运算符函数体，实现赋值
      //1.释放原来的内存
      //2.申请新内存拷贝数据
      //3.防止自赋值
      //4.返回自引用，支持连续=
      return *this;
  }

注意：
   (1)如果类中没有自定义拷贝赋值运算符函数，则系统自动提供一个缺省拷贝赋值运算符函数，本质就是按照字节进行复制
   (2)缺省拷贝赋值运算符函数往往不能实现深赋值，需要自定义赋值运算符函数,以获得真正意义上的副本

3.静态成员
  static修饰局部变量：生命周期变长
  static修饰全局变量：防止其他文件
使用
  static修饰函数：防止其他文件使用
  static修饰成员：该成员属于整个类，而不是单一的对象

3.1 静态成员变量
(1)
格式
   class 类名
   {
      static 数据类型  静态成员变量名;
   };
(2)注意
   a.静态成员变量必须在类的外部单独定义，格式：
    数据类型 类名::静态成员变量名
= 初始值;
   
   b.静态成员变量的存储形式与全局变量一样，所不同的是受到作用域和访控属性的影响

   c.静态成员属于整个类，也就是在所有对象间共享，既可以通过类名去访问，也可以通过对象名去访问;而非静态成员变量属于具体的对象

   d.对类进行sizeof计算时，不包括静态成员变量的大小

3.2 静态成员函数
(1)格式
   class 类名
   {
       static 返回值类型 函数名(形       参表)
       {
           函数体;
       }
   };

(2)注意
   a.对于静态成员函数来说，只能访问静态成员，不能访问非静态成员;对于非静态成员函数来说，既可以访问非静态成员，也可以访问静态成员
   b.没有this指针，没有常属性

思考：
   要求自定义一个类，这个类有且只能有创建一个对象.
   
4.成员指针
如：
   Student{};
   Student s;
   string* ps 
      = &s.m_name;//普通指针

4.1 指向成员变量的指针
(1)定义形式
   数据类型 类名::*指针变量名;   
(2)初始化/赋值
   指针变量名 = &类名::成员变量名;
(3)使用(解引用)
   对象.*指针变量名;
   对象指针->*指针变量名;

4.2 指向成员函数的指针
(1)定义
   返回值类型 (类名::*指针名)(形参   表);
(2)赋值/初始化
   指针名 = &类名::成员函数名;
(3)使用(解引用)
   (对象.*指针名)(实参表);
   (对象指针->*指针名)(实参表);   

注意：
   对于指向静态成员函数的指针不需要加类名::的限定

明日预报：
   (1)输入输出运算符重载
   (2)双目运算符重载
   (3)单目运算符重载
   (4)不能被重载的运算符
   (5)只能定义为成员形式的运算符






 









    