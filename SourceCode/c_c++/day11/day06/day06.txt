复习：
1.析构函数
1.1 格式
  class 类名
  {
     ~类名(void)
     {
        析构函数体;
     }
  };

1.2 注意
  (1)如果一个类中没有自定义析构函数，那么系统会自动提供一个缺省析构函数
  (2)缺省析构函数不会负责释放动态资源，这时需要自定义析构函数进行释放，释放的资源不仅仅是内存，文件的关闭，socket的关闭等

2.拷贝构造和拷贝赋值运算符函数
2.1 拷贝构造
(1)格式
   class 类名
   {
      类名(const 类名& 对象名)
      {
          拷贝构造函数体;
      }
   };  

(2)注意
   a.如果类中没有自定义拷贝构造函数，那么系统会提供一个缺省拷贝构造函数，本质就是按照字节进行复制
   b.缺省拷贝构造函数往往不能进行深拷贝，需要自定义拷贝构造函数，从而实现拷贝源的真正副本
   
(3)拷贝构造的时机
   a.使用同类型对象进行初始化
   b.使用对象作为函数的参数
   c.函数返回对象时(受编译器优化影响)

2.2 拷贝赋值运算符函数
(1)格式
class 类名
{
   类名& operator=(const 类名& 对   象名)
   {
	//1.释放原来的内存空间
        //2.分配新的内存空间
        //3.防止自赋值
        //4.返回自引用，连续赋值
   }   
};

(2)注意：
   如果类中没有自定义拷贝赋值运算符函数，则系统提供缺省函数，缺省函数只能进行字节的复制，往往不能实现深赋值，需要自定义拷贝赋值运算符函数

3.静态成员
3.1 静态成员变量
(1)格式
   class 类名
   {
     static 数据类型 变量名;
   };
(2)注意
   a.静态成员变量必须在类外单独定义
数据类型 类名::变量名 = 初始值;
   b.静态成员变量存储形式与全局变量一样，所不同受到作用域和访控属性的限制
   c.静态成员变量属于整个类，所有对象间共享，既可以通过类名::去访问，也可以通过对象名去访问
   d.sizeof不包括静态成员变量的大小

3.2 静态成员函数
(1)格式
   class 类名
   {
      static 返回值类型 函数名(形      参表)
      {
          函数体;
       }
   };

(2)注意
   a.静态成员函数只能访问静态成员,非静态成员函数既可以访问非静态成员，也可以访问静态成员
   b.没有this指针，也就是没有常属性

4.成员指针
4.1 指向成员变量的指针
(1)声明/定义
   数据类型 类名::*指针名;
(2)赋值/初始化
   指针名 = &类名::成员变量名;
(3)使用/解引用
   对象.*指针名;
   对象指针->*指针名;

4.2 指向成员函数的指针
(1)声明/定义
   返回值类型 类名::*指针名(形参表);

(2)赋值/初始化
   指针名 = &类名::成员函数名;

(3)使用/解引用
   (对象.*指针名)(实参表);
   (对象指针->*指针名)(实参表);

注意：
   对于指向静态成员函数的函数指针，不需要使用类名::限定
---------------------------------
今天内容：
   (1)输入输出运算符重载
   (2)友元类和友元函数
   (3)双目运算符重载
   (4)单目运算符重载
   (5)不能被重载的运算符
   (6)只能定义为成员形式的运算符   

1.输入输出运算符重载
如：
  int num = 10;
  cout << num << endl; //10
  char c = 'A';
  cout << c << endl; //'A'
  double d = 3.14;
  cout << d << endl; //3.14
  Student s;
  cout << s << endl;

解析为：
  cout.operator<<(num);
  cout.operator<<(c);
  cout.operator<<(d);
  cout.operator<<(s);

再次解析：
  cout.operator<<(int);
  cout.operator<<(char);
  cout.operator<<(double);
  cout.operator<<(Student);

  /usr/include/c++/4.6/ostream文件
  ostream是一个类类型，是cout的数据类型

再次解析：
  operator<<(cout,s);
  operator<<(ostream,Student);

注意：
   cin是istream类型的对象

练习：
   自定义一个分数类,属性有：分子和分母,提供一个有参的构造函数，要求支持输入输出运算符重载
如：
   2/3  分母不可以为0

2.友元类和友元函数
  使用friend关键字修饰的类和函数

(1)友元不是成员，只是为了声明它可以访问我的私有部分而已，被声明的友元可以访问类中的任何成员
(2)友元声明可以出现在类的公有、私有、保护任何一个部分，效果都是一样的，不受访控属性的限制，一般放在类的尾部

3.双目运算符重载
格式：
   L/*左操作数*/ #/*运算符*/ R(右操作数)
   => L.operator#(R); 成员形式
   => operator#(L,R); 非成员形式

如：   
   s + s2; 
   => s.operator+(s2);
   => operator+(s,s2);

建议：
   尽量使用成员形式的重载函数

练习：
   在分数类中，编写支持 + - += -=运算符重载
   1/2 + 1/3 = 3/6 + 2/6 = 5/6

4.单目运算符重载
4.1 格式：
    O/*操作数*/ #/*操作符*/
  =>O.operator#(); 成员形式
  =>operator#(O);  非成员形式

练习：
   自定义复数类,要求支持输出运算符重载即可

4.2 自增减运算符的重载
(1)前缀自增减运算符
   a.表达式的值是增减以后的值
   b.运算函数返回的是操作数的引用
   c.成员形式的运算符函数没有参数，友元形式的运算符函数只有一个参数 - 操作数
   d.可以连用

(2)后缀自增减运算符
   a.表达式的值是增减以前的值
   b.运算函数返回的增减以前的副本
   c.成员形式运算符函数有一个int类型的哑元参数;友元形式运算符函数有两个参数，第一个是操作数，第二个是int类型的哑元
   d.不可以连用

练习：
   自定义分数类,要求有参的构造函数，支持输出运算符重载，负号重载，以及前后缀++运算符重载

4.3 类型转换运算符函数
  在源类型中定义如下形式的函数：
  operator 目标类型(void)
  {
      构造一个目标类型的对象，返回
  }

功能：
 将源类型的对象转换为目标类型的对象

注意：
  如果在源类型中提供类型转换运算符函数的同时，在目标类型中定义了类型转换的构造函数，则对于隐式类型转换则优先选择类型转换运算符函数，而对于显式类型转换，则优先选择类型转换的构造函数

建议：
   建议不要提供两个，优先选择构造函数的方法(explicit)

5.不能被用户重载的运算符
  :: - 作用域限定符
  .  - 成员访问操作符
  .* - 成员指针解引用
  ?: - 三目运算符
  sizeof - 计算类型的大小
  typeid - 获取数据类型的名称

注意：
  (1)操作符的操作数中没有类类型的操作数，不能重载
  (2)不能通过重载运算符去发明新的操作符
  如： *  **
  
作业：
   实现一个整型的数组类IntArray,通过构造函数来指定数组的容量，注意在析构函数释放资源，提供的成员函数有：
   push() 在数组的尾部插入一个元素
   pop()  在数组的尾部弹出一个元素
   get()  根据下标获取一个元素的值
   set()  根据下标设置一个元素的值
   print() 打印数组中的所有元素

明日预报：
   (1)只能用成员形式重载的运算符
   (2)new/delete操作符的重载
   (3)封装和继承的初识
   (4)继承的特性
   (5)子类及其函数的特性
   (6)多重继承和虚继承


























  





