复习：
1.C++中的函数
1.1 函数的重载
(1)概念
   在同一个作用域中，函数名相同，函数的参数列表不同构成重载关系，在不同的作用域中，遵循的标示符隐藏规则

(2)重载的方式
   a.函数名相同，参数的类型不同
   b.函数名相同，参数的个数不同
   c.函数名相同，参数的顺序不同
   d.函数名相同，const修饰的常函数和普通的成员函数构成重载(以后讲到)

(3)比较特殊的重载关系
(4)重载的匹配原则
   完全匹配 > 常量匹配 > 升级转换 > 标准转换 > 自定义转换 > 省略匹配

1.2 重载的原理
(1)C++的编译器通过对函数进行换名，将函数的参数表信息体现在新的函数名中，从而构成了重载
(2)C程序可以通过C++编译器换名之后的新函数名去调用C++模块中的函数
(3)使用extern "C"关键字修饰的函数明确要求编译器不要对函数进行换名

1.3 缺省参数
如：
  void fn(int i,char c = 'A',char* p = NULL){}

(1)缺省参数必须靠右
(2)如果函数的声明和定义分开，那么缺省值写在声明部分
(3)避免由于缺省参数引发的重载冲突

1.4 哑元
   只有数据类型没有名称的参数叫哑元
如：
   int fn(int){...}

作用：
   (1)为了兼容以前的代码
   (2)区分前后 ++/-- 运算符重载

1.5 内联
   使用inline关键字修饰的函数

注意：
   (1)inline仅仅表示一种建议不是要求,虽然有inline修饰但是也不一定做内联处理
   (2)多次调用小而简单的函数使用内联
   (3)调用次数极少并且复杂的函数不适合内联
   (4)递归不能内联

2.动态内存
C语言中：  malloc/calloc/realloc/free
C++中：
  除了对C兼容之外，new/delete

2.1 申请指定类型变量大小的空间
   int* pi = new int;
   delete pi; pi = NULL;

   int* pi = new int(66);
   delete pi; pi = NULL;

2.2 申请数组大小的空间
   int* pi = new int[5];
   delete[] pi; pi = NULL;      

   int* pi = new int[5]{...};
   delete[] pi; pi = NULL;

2.3 申请N维数组返回N-1维的数组指针
如：
    int (*pi)[4] = new int[3][4];

2.4 定位分配
   new (指针) 数据类型(初始值);
         |
       表示申请内存的起始地址

3.引用

3.1 概念
  引用并不是一种独立的数据类型，仅仅是一个别名

如：
  int a = 10;
  int& b = a; //a起别名b
  int& c = b; //再起个别名c

3.2 引用和指针的区别
(1)引用必须初始化，指针可以不初始化
(2)引用不能为空，指针可以
(3)引用不能更换目标，指针可以
(4)不能声明引用型数组，可以声明指针型数组

作业：
signal函数：

   typedef void (*sighandler_t)(int);
   sighandler_t signal(int signum,sighandler_t handler); 
  
解析：
   typedef void (*)(int) sighandler_t;
   void (*)(int) signal(int signum,void (*)(int) handler); 
   void (*signal(int signum,void (*handler)(int)))(int) ; 
  
描述：
   signal首先是一个函数
   有两个参数的函数:第一个参数是一个int类型，第二个参数是函数指针
   返回值也是一个函数指针 

   其中，第二个参数和返回值都是：一个指向参数为int,返回值类型为void的函数 的指针      
----------------------------------
今天内容：
   (1)引用
   (2)类型转换
   (3)C++社区给C程序员的建议
   (4)面向对象编程的概念
   (5)类和对象
   (6)构造函数
   (7)初始化列表及其必要性

1.引用
1.1 指针和引用的使用说明
(1)指针中*的停靠问题
   int* pi;
   int * pi;
   int *pi;// 效果都是一样的

不成文的规则：
   如果定义一个指针变量时，习惯上让*停靠在数据类型的那边;如果定义多个指针变量时，习惯上让*停靠在变量名的那边
如：
   int* pi;
   int *pi,*pj;

(2)引用中&的停靠问题
   int& b = a;
   int & b = a;
   int &b = a;//效果一样
   
   int& b = a; 
   int &m = a,&n = b;//同上

(3)起别名的方式去使用
   typedef int* PINT;
   typedef int& RINT;
   PINT i,j; //两个指针
   RINT m = a,n = b; //两个引用

1.2 扩展
(1)可以定义指向指针的指针，但是不可以定义指向引用的指针
如：
   int a = 10;
   int* pa = &a;//一级指针
   int** ppa = &pa;//二级指针
      
   int& b = a;//a起别名为b
   int& *pb = &b; //error
  
(2)可以定义引用指针的引用，不可以定义引用 引用的引用
如：
   int a = 10;
   int* pa = &a;
   int* &ra = pa; //ok

   int& b = a;
   int&& rb = b; // error   
   
(3)可以声明指针数组，不可以声明引用型数组，但是可以声明数组的引用
如：
   int* pa[5]; //指针数组
   int& pa[5];// error

   int (*pa)[5];//数组指针
   int (&pa)[5];//数组引用   

1.3 引用作为函数的参数
(1)使用引用型参数可以在函数中对实参变量的值进行修改
(2)使用引用型参数可以避免参数在传递过程中发生数据内容的拷贝
(3)通过将参数定义为常引用，防止在函数体内对实参的意外修改，同时还可以接受常量型实参   
(4)引用作为函数的形参实际上就是址传递

建议：
   对于函数的参数来说，尽量加&，尽量加const,一般用于自定义数据类型

练习：
   分别使用int类型变量、指针以及引用作为函数的参数，来交换两个实参变量的值

1.4 引用作为函数的返回值
  永远不要返回对局部变量(包括函数的形参)的引用,可以返回 静态局部变量/全局变量/动态内存/实参的引用/成员变量 的引用,这些返回值都是安全的

2.类型转换
   隐式类型转换： 一般从小 -> 大
   显式类型转换(强制类型转换): 一般从大到小的转换

如：
  char c ;
  int i = (int)c; //C语言风格
  int i = int(c); //C++风格

(1)静态类型转换
   目标类型 变量名 = 
static_cast<目标类型>(源类型变量);

功能：
   如果在目标类型和源类型之间只要有一个方向上可以做隐式类型转换，那么在两个方向上都可以做静态类型转换；反之，如果在两个方向上都不能做隐式类型转换，那么在两个方向上都不能做静态类型转换

(2)常量类型转换
   目标类型 变量名 = 
const_cast<目标类型>(源类型变量);

功能：
   主要用于去除指针/引用上的常属性

注意：
   试图通过const_cast去修改一个常量的值，那么后果是不确定的

(3)重解释类型转换
   目标类型 变量名 = 
reinterpret_cast<目标类型>(源类型变量名);

功能：
   主要用于任意两种指针类型之间的转换，以及指针和整型之间的转换

(4)动态类型转换
   目标类型 变量名 = 
dynamic_cast<目标类型>(源类型变量名);

功能：
   主要用于具有多态特性的父子类 指针/引用 之间的转换(以后讲到)

3.C++社区对C程序员的建议
(1)尽量少使用宏，而代之以 const 和 enum 以及 inline替代之
如：
   #define PI 3.14
   const double pi = 3.14;     
   
  #define MAX(x,y) (x)>(y)?(x):(y)
   inline int max(int x,int y)
   {
       return x>y?x:y;
   }

(2)变量随使用随声明
(3)不用malloc/free 而用new/delete
(4)避免使用void*、指针算数、联合以及强制类型转换
(5)尽量少使用C风格字符串，代之以string对象
   strcpy/strcmp/strcat/...
(6)理解面向对象的编程思想

4.面向对象编程的初识
4.1 什么是对象？
   万物皆对象，无论是任何对象，都可以去分析它的属性以及行为

4.2 什么是面向对象？
   以属性和行为的观点去分析现实世界的事物的方式 叫 面向对象
   面向对象 -> 大处着眼
   面向过程 -> 关注的整个过程的细节

4.3 什么是面向对象编程？
   先采用面向对象的思想去分析，然后采用面向对象的编程语言把分析出来的方法表达出来

4.4 为什么需要面向对象编程？
   软件产业化发展的需求

5.类和对象
  把对象的共性提取出来就组成类
如：

学生类:
   属性：姓名  年龄  性别  学号 
   行为：吃饭  学习  娱乐  
教师类：
   属性：姓名  年龄  性别  职称
   行为：吃饭  授课  娱乐
   
   采用C++语法形式将上述过程描述出来就叫面向对象编程

5.1 类的定义
格式：
   class 类名{}; 
如：
   class Student{};

5.2 成员变量(属性)
格式：
   class 类名
   {
       数据类型 成员变量名;
       ...
   };  
如：
   class Student
   {
       string m_name;//姓名
       int m_age; //年龄
   };

5.3 成员函数(行为)
格式：
   class 类名
   {
      返回值类型 函数名(形参表)
      {
          成员函数体;
      }
   };
如：
   class Student
   {
       string m_name;
       int m_age;

       void learn(const string&      lesson){ ... }
   };

5.4 访控属性
(1)public 公有的
(2)protected 保护的
(3)private  私有的

访问限定符 访控属性 本类 子类 类外
---------------------------------
public      公有的  ok   ok   ok
protected   保护的  ok   ok   no
private     私有的  ok   no   no

结构体和类的区别：
  (1)关键字不同
  (2)类中默认访控属性是私有的，而结  构体中默认访控属性是公有的

6.构造函数
  函数名与类名相同，函数没有返回值类型(连void都没有)的函数叫构造函数

格式：
   class 类名
   {
      类名(形参表)
      {
         构造函数体;
      }
   };

注意：
   当对象被创建时构造函数会被自动调用，一般用于对对象进行初始化,也就是给对象的成员变量进行初始化

作业：
   自定义一个Girl类,属性有：姓名，年龄以及是否有男朋友，行为有：带参的构造函数，以及打印所有属性的成员函数

明日预报：
   (1)构造函数
   (2)初始化列表及其必要性
   (3)支持自定义类型转换的构造函数
   (4)this指针
   (5)const对象和成员函数
   (6)析构函数





























  












   