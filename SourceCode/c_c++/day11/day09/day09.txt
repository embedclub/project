复习：
1.子类中的拷贝构造和拷贝赋值
  在子类中的拷贝构造和拷贝赋值函数中，也可能需要显式的指定基类子对象的构造和赋值方式

2.多继承和虚继承
2.1 多继承语法
  class 子类名 : 继承方式 父类名1，继承方式 父类名2
  {
     属性和行为等
  };

2.2 钻石继承
     A
    / \
   B   C   
    \ /
     D

2.3 虚继承
(1)在公共基类的继承方式前加上virtual关键字修饰
(2)在最终子类中可能需要显式的指定公共基类子对象的构造方式 
(3)目标：
   在最终子类中，公共基类子对象只有一份，以避免从不同继承路径去访问时发生数据不一致的现象

注意：
   如果在多个父类中存在函数名相同，参数列表不同的函数不能构成重载，一旦子类中存在同名的函数则产生隐藏

3.多态
3.1 多态的特性
  (1)使用父类指针/引用 调用函数则选择父类中的函数
  (2)使用父类指针/引用 调用虚函数则选择子类中的覆盖版本
  (3)虚函数：使用virutal关键字修饰
     虚函数覆盖：在子类中存在与父类中函数具有相同的函数原型，则产生覆盖，子类的覆盖版本也是虚函数(无论是否使用virtual关键字修饰)

4.虚析构
(1)主要用于delete一个指向子类对象的父类指针时，实际调用子类中的析构函数，子类析构函数会自动调用父类析构函数
(2)一般而言，如果一个类中存在虚函数，则应该提供一个虚析构

5.多态的底层实现
如：
   class B : public A{};
   A* pa = new B;
   pa->foo();
   编译阶段无法缺省pa的真正指向，编译器所做的就是用一段代码替换上面的函数调用，这段代码执行以下的流程：
  (1)确认pa所真正指向的对象类型
  (2)根据对象中虚函数表的地址寻找虚函数表，在虚函数表中找到函数标示符所对应的函数地址
  (3)根据函数地址调用此函数
----------------------------------
今天内容：
   (1)纯虚函数和抽象类
   (2)类型信息和类型转换
   (3)异常机制
   (4)I/O操作

1.纯虚函数和抽象类
(1)虚函数：
使用virtual关键字修饰的函数
  
(2)纯虚函数：
形如：
virtual 返回值类型 函数名(形参表) = 0;
  
(3)抽象类：
   至少包含一个纯虚函数的类，抽象类不能实例化对象

(4)纯抽象类
   完全由纯虚函数组成的类

注意：
   一个抽象类的子类如果没有为该基类中的全部纯虚函数提供覆盖，则该子类也是抽象类,也就不能实例化对象
(01abstract.cpp)

2.类型信息和类型转换
2.1 类型信息
  sizeof 计算数据类型所占的大小
  typeid 获取数据类型的名称
如：
  int n = 10;
  sizeof(int) = 4;
  sizeof(n) => sizeof(int) 等价的
  typeid(int) => typeid(n) 等价的
  
  typeid返回typeinfo类型的对象，在该对象上调用成员函数name()来获取类型的名称，函数name的返回值是C风格字符串
  #include <typeinfo>
  typeinfo类型的对象支持==运算符

总结：
  只有在具有多态关系的父子类之间，才能通过typeid正确地判断一个指针实际指向的对象类型
(02typeid.cpp)

2.2 类型转换
  static_cast 静态类型转换
  const_cast  常量类型转换
  reinterpret_cast 重解释类型转换
  dynamic_cast 动态类型转换   
  (03cast.cpp文件)

3.异常
3.1 异常捕获
  try
  {
     可能引发异常的语句;
  }
  catch(异常类型1 ex)
  {
     异常处理语句;
  }
  catch(异常类型2 ex)
  {
     异常处理语句;
  }
  ...
  catch(...)
  {
     异常处理语句;
  }

3.2 异常抛出
  throw 异常类型;
  (04exception.cpp文件)

3.3 异常的基本用法
(1)抛出简单数据类型变量,通过异常变量的数值进行区分不同的异常
如：
   throw 100; 
(2)抛出类类型异常对象,通过异常类型区分不同的异常
(3)从标准异常类继承
   exception 标准异常类
   /usr/include/c++/4.6/exception
   virtual/*虚函数，可以被覆盖*/ const char*/*返回值类型*/ what() const/*常函数*/ throw()/*不抛出任何异常*/;
(4)继续抛出异常
   a.发生异常之后可以不处理，继续向上抛
   b.只处理一部分，处理完毕之后继续抛出异常
如：
   try
   { 
      ....;
   }
   catch(... ex)
   {
       //...
       throw ex;   
   }
(5)异常说明
   返回值类型 函数名(形参表) throw(异常类型1，异常类型2，...){}
(05exception.cpp)

4.I/O操作
4.1 文本文件I/O操作
(1)格式化I/O
如：
   fprintf/fscanf 操作文件 
   sprintf/sscanf 操作字符串
   ofstream/ifstream 操作文件

(2)文件位置
   fseek() C语言
   seek()  UC   
   fs.seekg()/fs.seekp() C++

   ftell() 获取文件的读写位置
   rewind() 回到文件开始位置
   fs.tellg()/fs.tellp() 获取位置
   
4.2 非格式化I/O
   fgetc()/fputc() 按照字符操作
   fgets()/fputs() 按照字符串操作

   ofs.put() 写入一个字符
   ifs.get() 读取一个字符
   ifs.eof() 判断是否读到文件尾

4.3 二进制I/O
   fread()/fwrite() C语言读写
   read()/write()   UC
   
   ifs.read()/ofs.write() C++    
   
4.4 格式控制
   



