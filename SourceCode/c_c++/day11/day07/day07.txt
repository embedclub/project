复习：
1.输入输出运算符重载
如：
  int num = 10;
  // cout.operator<<(int);
  cout << num << endl; 
  Student s;
  // cout.operator<<(Student);
  // operator<<(cout,Student);
  // cout是对象，ostream类型的
  cout << s << endl;

  friend operator<<(ostream& os,const Student& s){}

  // cin.operator>>(s);
  // operator>>(cin,s);
  // cin 是 istream类型的 对象
  cin >> s;
  friend opertor>>(istream& is,Student& s){}

2.友元类和友元函数
  使用friend关键字修饰的类和函数
(1)友元不是成员，只是声明该友元可以访问类中的私有成员，也就是可以访问类中的任何成员
(2)友元声明可以写在类中的公有、保护、私有任意一个部分,不受访控属性的影响,一般情况写在类的尾部

3.双目运算符重载
3.1格式：
  L#R 
  => L.operator#(R);  成员形式
  => operator#(L,R);  非成员形式

如：
  Complex c1,c2;
  // c1.operator+(c2);
  // operator+(c1,c2);
  cout << c1+c2 << endl;
  
4.单目运算符
4.1 格式
  O#
  => O.operator#(); 成员形式
  => operator#(O);  非成员形式

如：
  Complex c;
  // c.operator-();
  // operator-(c);
  cout << -c << endl;

4.2 自增减运算符
(1)前缀自增减运算符
   a.表达式的结果是增减以后的值
   b.运算符函数返回操作数的引用
   c.成员形式的重载没有参数，对于非成员形式的重载只有一个参数 - 操作数
   d.可以连用

(2)后缀自增减运算符
   a.表达式的结果是增减以前的值
   b.运算符函数返回操作符之前的副本
   c.成员形式的重载有一个int类型的哑元，非成员形式有两个参数，第一个参数是操作数，第二个是int类型的哑元

4.3 类型转换运算符函数
   在源类型中定义如下形式的函数：
   operator 目标类型(void)
   {
      构造一个目标类型对象，返回
   }

注意：
   在源类型中提供类型转换运算符函数的同时，在目标类型中提供了类型转换的构造函数，那么对于隐式类型转换优先选择类型转换运算符，而对于显式类型转换优先选择构造函数

建议：
   不要同时两种方法，优先选择构造

5.不能被用户重载的运算符
  ::  . .*  ?:  sizeof  typeid  
注意：
  (1)操作符中没有类类型的操作数，则不能进行重载
  (2)不能通过运算符重载发明新的运算符

作业：
----------------------------------
今天内容：
   (1)只能用成员形式重载的运算符
   (2)new/delete操作符的重载
   (3)封装和继承的初识
   (4)继承的特性
   (5)子类及其函数的特性
   (6)多重继承和虚继承 

1.只能用成员形式重载的运算符
(1)[] 下标操作符 
(2)() 函数操作符
(3)* -> 间接操作符

2.new/delete操作符的重载

注意：
  如果需要在调用构造函数之前做一些初始化工作/在调用析构函数之后做一些善后工作，则可以通过new/delete运算符重载的函数来实现
  
3.封装和继承的初识
3.1 概念
(1)封装
   使用访问控制符对类型中的属性和行为进行访问限制的机制
   public  protected  private    
(2)继承
   表达类型之间共性和特性的依存关系的一种语言机制

如：
学生类：
   属性：姓名  年龄  学号
   行为：吃饭  学习
教师类：
   属性：姓名  年龄  职称
   行为：吃饭  授课

将学生类和教师类的共性提取出来，组成人类:
   属性：姓名 年龄
   行为：吃饭

剩下的是学生类和教师类的特性：
学生类：
   属性：学号
   行为：学习
教师类：
   属性：职称
   行为：授课   

于是发现：
         人类:(姓名,年龄,吃饭)
        /       \ 
(学号,学习)学生类 教师类(职称,授课)

   人类：父类/基类
   学生类/教师类：子类/派生类 

3.2 继承的语法格式
  class 子类名 : 继承方式 父类名1,继承方式2 父类名2，...
  {
     子类类型的定义;
  };  
   
继承方式：
   public: 公有方式继承
   protected：保护方式继承
   private: 私有方式继承

练习：
   vi 07inherit.cpp文件，自定义Person类和Teacher类，提供构造函数和行为

4.继承的特性
(1)一个子类类型的对象在任何时候都可以看做该类的基类类型的对象
(2)一个基类类型的对象如果作为子类类型的对象被访问，有可能引发非法内存访问错误
(3)在子类中可以访问基类中的公有和保护成员，但是不可以访问私有成员
(4)在子类中可以定义和基类中同名的标示符，子类隐藏父类(名字隐藏)

5.继承方式和访问控制符

5.1 访问控制符

访控符 访控属性 本类 子类 类外 友元
---------------------------------
public 公有的    ok   ok   ok  ok
protected 保护的 ok   ok   no  ok
private 私有的   ok   no   no  ok

5.2 继承方式的特性
基类中  公有子类  保护子类 私有子类
----------------------------------
公有的  公有的    保护的   私有的
保护的  保护的    保护的   私有的
私有的  私有的    私有的   私有的

注意：
  一般采用公有方式继承，保护和私有的继承方式很少使用

如：
   class A
   {
   public:
      void print(void){....}
   };
   class B : private A
   {
   public:
      void show(void)
      {
          print();
          ...
      }
   };

   class C
   {
      print();
   };

6.子类中的构造函数和析构函数
(1)在子类的构造函数中可以显式地构造其基类部分("基类类名(实参)"),否则系统会试图以无参的形式去构造基类子对象
(2)子类中的析构函数会自动地调用父类中的析构函数从而释放基类子对象，而父类中析构函数不会自动调用子类的析构函数
(3)delete一个指向子类对象的父类指针时，被调用的仅仅是父类中的析构函数，而该析构函数不会自动调用子类中的析构，从而造成内存泄露,可以通过使用虚析构解决此问题(明天讲到)

明日预报：
   (1)子类中的拷贝构造和拷贝赋值
   (2)多继承和虚继承
   (3)多态的初识
   (4)虚析构的特性和使用
   (5)多态的底层实现
   (6)纯虚函数、抽象类的概念











 

