复习：
1.只能使用成员形式重载的运算符
(1)[] 下标操作符
(2)() 函数操作符
(3)* -> 间接操作符

2.new/delete运算符重载
形式：
  void* operator new(size_t size)
  {
      //使用malloc申请内存 
  }

  void operator delete(void* p)
  {
     //使用free释放内存
  }

  void* operator new[](size_t size)
  {
     //使用malloc申请内存
     //多4个字节,包括了元素个数等     信息
  }

  void operator delete[](void* p)
  {
     //释放free释放内存
  }

3.封装和继承的初识
3.1 概念
  封装：使用访问控制符来限制对类型中属性和行为的访问
  继承：表达类型之间的共性和特性的语言机制
   Person类(父类/基类)
   /   \
Student  Teacher(子类/派生类)

3.1 格式
  class 子类名 : 继承方式 父类名1,继承方式 父类名2,...
  {
      子类的属性和行为;
  }

3.2 继承的特性
(1)子类类型的对象在任何时候都可以看做父类类型对象去使用
(2)如果父类类型的对象当做子类类型的对象去访问，可能带来非法访问内存错误
(3)在子类中可以访问父类中的公有和保护成员，但是不可以访问私有成员
(4)在子类中定义和父类中同名的标示符，则子类隐藏父类(名字隐藏)

3.3 访问控制符和继承方式
访控符 访控属性 本类 子类 类外 友元
----------------------------------
public  公有的   ok  ok   ok   ok
protected 保护的 ok  ok   no   ok
private   私有的 ok  no   no   ok

父类访控 公有子类 保护子类 私有子类
----------------------------------
公有的   公有的   保护的   私有的
保护的   保护的   保护的   私有的
私有的   私有的   私有的   私有的


3.4 子类中的构造函数和析构函数
(1)在子类构造函数可以显式地指定父类子对象的构造方式("父类类名(实参)"),否则系统会试图用无参的形式去构造
(2)子类中的析构函数会自动调用父类中的析构函数，父类中的析构函数不会自动调用子类中的析构函数
(3)delete指向子类对象的父类指针时，仅仅被调用的是父类的析构函数，子类的析构不会被调用，从而造成内存泄露，通过虚析构解决此问题
---------------------------------
今天内容：
   (1)子类中的拷贝构造和拷贝赋值
   (2)多继承和虚继承
   (3)多态的初识
   (4)虚析构的特性和使用
   (5)多态的底层实现
   (6)纯虚函数、抽象类的概念

1.子类中的拷贝构造和拷贝赋值
  子类中的拷贝构造和拷贝赋值可能也需要显式的指定父类子对象的拷贝构造和拷贝赋值的方式

2.多继承和虚继承
2.1 格式：
  class 子类名 : 继承方式 父类名1,继承方式 父类名2,...
  {
     //子类中的属性和行为
  };  

如：
      员工类
      /    \
销售员工类 管理者类
      \    /
     销售管理类

   叫做：钻石继承

2.2 虚继承要点
(1)在对公共基类的继承方式之前加virtual关键字修饰
(2)可能需要在最终子类中显式指定公共基类的构造方式
(3)目标：公共基类子对象在最终子类中只有一份，以避免从不同继承路径访问公共基类子对象时发生数据不一致的现象

注意：
  在多继承中，如果多个父类都有函数名相同，参数表不同的函数，继承到子类中不会构成重载，如果子类中存在同名的标示符，则产生隐藏(02diamond.cpp文件)

练习：
   写一个圆类(Circle),属性有：圆心坐标和半径；再写一个桌子类(Table),属性有：高度;两个类共同派生一个圆桌类(RoundTable),属性：颜色
   要求：定义一个圆桌类的对象，打印出圆桌的桌面面积，体积以及颜色
   圆的面积：PI*r*r;
   圆的体积公式：底面积 * 高
   (vi 03circle.cpp)

3.多态的初识
3.1 多态的特性
(1)通过指向子类对象的 基类指针/引用 只能调用基类中的成员函数
(2)通过指向子类对象的 基类指针/引用 调用虚函数,实际上调用的是子类中的版本
(3)虚函数和虚函数覆盖
  虚函数：使用virtual关键字修饰的函数
  虚函数覆盖：在子类中定义一个与基类中具有相同的函数原型的函数，即构成虚函数覆盖，该虚函数的覆盖版本也是虚函数(无论是否使用virtual修饰)
(04dynamic.cpp文件)

笔试题：
   class B : public A{};
基类中：virtual A* foo(void){...}
子类中：virtual B* foo(void){...}     
 => 产生虚函数覆盖

4.虚析构
  使用virtual关键字修饰的析构函数  

(1)虚析构函数实际上就是为了保证delete一个指向子类对象的基类指针时，实际上被调用的是子类中的析构函数，而子类中的析构函数会自动调用基类中的析构函数
(2)一般而言，如果一个类中有虚函数，那么该类就应该提供一个虚析构函数
(05destructor.cpp文件)

5.多态的底层实现  
5.1 实现流程
如：
   class A{...};
   class B : public A{...};
   A* pa = new B;
   pa->foo();
   当编译器编译上句代码时，它并不知道pa的所真正指向的真实对象(只有在运行时才会知道),编译器所能做的就是使用一段代码去替换上面的函数调用语句，这段代码依次执行下面的操作：
(1)首先弄清指针pa所指向的对象的真实身份
(2)然后通过这个对象的虚函数表指针去访问对应的虚函数表，并找到与foo函数标示符所对应的虚函数入口地址
(3)根据入口地址调用该函数

5.2 多态必要条件
(1)虚函数
(2)通过指针/引用 去调用

笔试题：
(1)
class A
{
public:
   void foo(void)
   {
       // this = &b;
       // this->bar();
       bar();//调用B类中的bar函数
   }
   virtual void bar(void){...}
};  

class B : public A
{
public:
   //虚函数覆盖
   void bar(void){...}
};    

int main(void)
{
    B b;
    b.foo();
    return 0;
}

(2)
构造函数、析构函数以及静态成员函数中，哪些函数可以是虚函数？
   析构可以是虚函数
   构造函数和静态成员函数不可以是虚   函数



