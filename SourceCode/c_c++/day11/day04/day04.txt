复习：
1.引用
1.1 使用说明
(1)*和&的停靠问题
   int* pi;
   int *pi,*pj;
   
   int& ra = a;
   int &ra = a,&rb = b;
(2)其别名的方式使用
   typedef int* PINT;
   typedef int& RINT;

1.2 扩展
(1)可以定义指向 指针 的指针，不可以定义指向 引用的 指针
(2)可以声明引用 指针 的引用，不可以声明引用 引用的 引用
(3)可以声明指针型数组，不可以声明引用型数组，可以声明数组引用

1.3 引用作为函数的参数
(1)引用作为函数的参数，可以修改实参的值
(2)避免数据的拷贝
(3)const修饰引用作为函数，避免了实参在函数中被修改，并且可以接受常量型实参
(4)引用就是址传递，本质上就是指针
  
1.4 引用作为函数的返回值
   永远不要返回局部变量的引用，可以返回 静态局部变量/全局变量/动态内存/成员变量/实参的引用 的引用都是安全的

2.类型转换
(1)静态类型转换
   目标类型 变量名 = 
static_cast<目标类型>(源类型变量);

(2)常量类型转换
   const_cast 去除 指针/引用 的常属性

(3)重解释类型转换
   reinterpret_cast 主要用于 任意类型的指针/引用之间的转换，甚至可以做指针和整型之间的转换

(4)动态类型转换
   dynamic_cast 主要用于具有多态特性的父子类 指针/引用 之间的转换

3.C++社区的建议
(1)尽量少使用宏，用const、enum以及inline替代之
(2)变量随使用随声明
(3)少使用malloc/free 多用new/delete
(4)避免使用void*、指针算数、联合以及强制类型转换
(5)少使用C风格字符串，代之以string
(6)理解面向对象编程思想

4.面向对象编程的初识
4.1 什么是对象？
   万物皆对象
4.2 什么是面向对象？
   通过属性以及行为的两个方面去分析现实世界的事物
4.3 什么是面向对象编程？
   采用面向对象的分析方法，采用面向对象的编程语言将分析的过程表达出来
4.4 为什么需要面向对象编程？
   软件产业化发展的需求

5.类和对象
5.1 类的定义
  class 类名{};
5.2 成员变量
  class 类名
 {
    数据类型 成员变量名;
    ...
 };
5.3 成员函数
  class 类名
  {
     返回值类型 函数名(形参表)
     {
        成员函数体;
     }
  };
5.4 访控属性
(1)public 公有的
(2)protected 保护的
(3)private 私有的

访问控制符 访控属性 本类 子类 类外
public    公有的    ok   ok   ok
protected 保护的    ok   ok   no
private   私有的    ok   no   no

与结构体的区别：
  a.关键字不同
  b.默认访控属性不同

6.构造函数
  函数名与类型相同，并且没有返回值类型(连void都没有)

格式：
   class 类名
   {
      类名(形参表)
      {
         构造函数体;
      }
   };

注意：
   当对象被创建时，自动调用构造函数进行初始化，也就是成员变量的初始化

作业：
---------------------------------- 今天内容：
   (1)构造函数
   (2)初始化列表及其必要性
   (3)支持自定义类型转换的构造函数
   (4)this指针
   (5)const对象和成员函数
   (6)析构函数    

1.构造函数
1.1 格式：
  class 类名
  {
     类名(形参表)
     {
        构造函数体;
     }
  };

练习：
   自定义Student类，属性有：姓名和年龄，提供一个show函数即可 

注意：
  (1)创建对象时会自动调用构造函数进行初始化,初始化成员变量
  (2)如果一个类中没有自定义构造函数，那么系统会自动提供一个无参的构造函数(缺省构造函数，默认构造函数);一旦出现任何形式的自定义构造函数，那么系统就不再提供无参构造函数

扩展：
   无参构造函数未必真的没有参数，而是可以用无参的形式去调用

2.初始化列表及其必要性
2.1 初始化列表
格式：
   class 类名
   {
       类名(形参表):成员变量名(形参名),...
       {
          构造函数体;
       }
   };   


注意：
   成员变量的初始化顺序和初始化列表中的先后顺序无关，而是取决于成员变量的定义顺序

笔试题：
   class Dumy
   {
   private:
      int m_len;
      string m_str;
   public:
      Dumy(const string& str):m_str(str),m_len(m_str.length());
   };
问题：
   请问上面的代码有没有问题？如果有问题如何解决？

解析：
   有问题，先给m_len赋值，而此时m_str还没有初始化，结果不正确

解决方案：
   (1)交换成员变量的顺序
   (2)m_len(str.length())

2.2 定义、声明、初始化的不同
   int num = 10; 
(1)声明
   类定义中的成员变量写法 叫做声明
(2)定义
   当使用类类型创建对象时，对象中的成员变量才会被定义,也就是分配内存
(3)初始化
   当对象被创建时，自动调用构造函数进行初始化，如果有初始化列表则按照初始化列表的方式进行初始化；如果没有则采用默认初始化方式,对于类类型的成员变量则调用默认构造函数初始化

执行流程：
   创建对象 -> 分配对象中成员变量的内存 -> 自动调用构造函数进行初始化 
-> 执行构造函数体;

2.3 初始化列表的必要性
(1)类中包含常量和引用型的成员变量，那么必须通过构造函数和初始化列表的形式进行初始化
(2)在子类中显式地构造其基类部分(以后讲到)

3.支持自定义类型转换的构造函数
  在目标类型中自定义如下形式的构造函数：
  目标类::目标类(const 源类& 源类对象){ ...}
  
功能：
   实现从源类型到目标类型的隐式转换
  
注意：
   通过使用explicit关键字可以指示该构造函数只能用于显式类型转换，以防止潜在的错误

4.this指针
概念：
   class B{};
   class A
   {
   public:
      void show(B b){...}
   };   
   
   int main(void)
   {
       B b;
       A a;
       a.show(b);	
   }
   其中a叫做调用对象，b叫做参数对象

4.1 this指针的概念
   一般而言，关键字this就是一个指针，对于一般成员函数来说，该指针指向调用对象;对于构造函数来说，该指针指向这个正在构造的对象

注意：
   构造函数和普通成员函数内部都隐含一个this指针，用于保存调用对象/正在构造对象的 地址

4.2 this指针的用途
(1)this指针可以用于在构造函数中区分与构造参数名相同的成员变量，初始化列表中不存在此问题
(2)this指针可以用于返回自引用的场合
(3)this指针可以作为函数的参数实现对象间的交互

5.const对象和const成员函数
(1)const修饰的函数叫做常量型函数，该函数中的this指针为常量型，以此防止对成员变量的意外修改
(2)通过常量类型的 指针/引用 只能访问其常量型的成员函数，否则引发编译错误
(3)常量型成员函数和非常量型成员函数之间构成重载，通过常量型对象、引用以及指针只能调用常量型的成员函数，而对于非常量型的对象、引用以及指针则优先调用非常量型成员函数
(4)使用mutable关键字修饰成员变量，表示该成员变量可以在常量型成员函数中被修改

复习：
   const int* pi = &i;// *pi不可变
   int const *pi = &i;// *pi不可变
   int* const pi = &i;// pi不可变
   const int* const pi;
   // pi 和 *pi 都不可改变

练习：
   自定义一个Clock类，
属性：时、分、秒，
行为：
     提供一个无参的构造函数实现用当   前系统的时间初始化成员变量时分秒
     提供一个run函数，每隔一秒打印   一次时间

提示：
   time(0) 获取系统时间
   localtime 拆出时分秒

明日预报：
   (1)析构函数
   (2)拷贝构造和拷贝赋值
   (3)静态成员
   (4)成员指针
   (5)输入输出运算符重载























 



   


