
XSI IPC: 共享内存 消息队列 信号量集

	信号量集：
	       一般用于进程间同步
	       信号量的集合（数组）
	       信号量和信号没有任何关系。
	       信号量本质是一个计数器（int）,负责控制访问共享资源的最大并行进程总数。信号量初始设为最大值，每个进程访问共享资源前计数减一，每个进程结束共享资源访问计数+1。当计数减为0时阻塞，直到计数重新大于0解除阻塞。
	    如果有多个共享资源需要分别控制最大并行进程数，就需要多个信号量，把多个信号量放在一个数组中，这个数组就叫信号量集。
	    编程时，系统提供的接口操作对象是信号量集，而不是单一的信号量。编程步骤：
	    1）生成key   ftok()
	    2）创建信号量集 semget()
	    3) 设置初始值 semctl()
	    4) 正常使用，访问共享资源信号量-1
	    	 访问结束信号量+1
	    	 semop
	    5) 销毁信号量集合
	        semctl(, IPC_RMID, ...)
	     sema.c
	     int semget(key, nsems, flag)
	     		key, 获取/创建信号量集的唯一标识
	     		nsems, 信号量的个数
	     		flag, IPC_CREAT IPC_EXCL mode
	     int semctl(semid, semnum, cmd, arg)
					semid,  要操作哪个信号量集
					semnum, 要操作第几个信号量
					cmd,  IPC_RMID ,删除信号量集合
								SETVAL, 设置semid信号量集中第semnum个
											   信号量的值为arg.val
							   union semum
							   {
							   		int val; 
							   		...
							   }
					      IPC_STAT
					      IPC_SET
		  semb.c
	int semop(int semid, struct sembuf *sops, unsigned nsops)
	    semid,
	    sops, 
	       struct sembuf
	       {
	       		sem_num; //信号量的下标
	       		sem_op;  //操作数
	       		sem_flg; //操作标记
	       }		
	   该函数对semid指定的信号量集合中，由sops参数所指向的包含nsops个元素的， 依次执行如下操作：
	若sem_op>0，将sem_op加到sem_num对应的信号量的计数值上去
	若sem_op<0, 将sem_op加到sem_num对应的信号量的计数值上去
	若sem_op=0, 直到sem_num对应的信号量计数为0才返回
	   sem_flg, 0 代表阻塞
	            IPC_NOWAIT ,非阻塞不等待，出错返回 
	  练习：进程Ａ 申请26个字节的共享内存空间，1秒 中写入
	        字符“ABCDE....Z”
	        进程B 获取该共享内存，读出该空间的有效数据
	        进程间的同步
	        思路， A 进程申请共享内存
                   申请一个信号量，信号量初始值设为0
                   向共享内存写入一个字符 信号量+1
                 B 进程获取该共享内存和信号量	 
                    信号量-1，成功
                    从共享内存中读出一个字符  
          cond1.c
          cond2.c     
	   深入：选做
	         生产者 消费者问题
	         当缓冲区满 生产者停止生产
	         当缓冲区空 消费者停止消费
	         
	         信号量 + 循环缓冲队列（ 队列）
总结：
		unix下进程间的通信方式有哪些种？
		各有什么特点？
		某情况下你选择哪种？
     1）共享内存是最快的ＩＰＣ机制，适用于进程间传递大批量的数据，但要自己负责完成进程的互斥访问，一般使用信号量
     2）如果进程间传递的数据具有很强的顺序性，可以考虑使用消息队列
     3）进程间的同步更多的考虑使用信号量机制 	
-----------------------------------------------------------
网络编程 : socket ,套接字
    1 、OSI（open system interconnection）,国际化标准组织（ISO）提出试图用于计算机在世界范围内互联通信的网络标准架构
    
   OSI 七层模型： 物理层  数据链路层  网络层  传输层
                  会话层 表示层 应用层
      该模型每层的协议设计的过于庞大复杂，招致了很多批评
linux网络编程模型： 物理层 数据链路层
                    网络层   传输层   应用层 
   2、协议：每一层干什么都有详细的规定
       应用层： HTTP（超文本传输协议）
                FTP    
                pop3 smtp (邮件相关)
                telnet
       传输层： TCP 基于连接传输控制协议
                UDP 数据报协议
       网络层： IP ARP（地址解析 IP地址转化为物理地址）RARP
       数据链路层： PPP （点对点协议）
			 物理层： RJ-45              
   3、协议簇(族)：以上每个协议功能有限，会把多个协议组成一个协议簇，以主体协议命名协议簇  TCP/IP 
   4、TCP，面向连接的、可靠的、基于IP的传输层协议
      UDP，无连接的传输协议提供面向事物的不可靠信息传送服务
   5、IP地址：就是计算机在网络中的唯一标识，网络中的计算机使用IP地址（学号  门牌号）
     IP地址本质就是一个整数
     网卡的物理地址(MAC地址)：厂家给的编号，确保唯一性
     IP地址分为IPV4 和IPV6， IPv4使用32bit整数代表IP地址
       IPv6,使用128bit表示IP地址，目前不是主流
       
       ifconfig
       sudo ifconfig eth0 192.168.1.8
       ping  
       IP地址：429643872 	
               把IP地址的4 字节每个字节看成一个数字，点分十进制：192.168.1.8
       IP地址 = 网络号 + 主机号  
                 192.168.1.8
       子网掩码  255.255.255.0
       网络号 ：IP地址（32bit） & 子网掩码 (32bit) 
       判断某两台主机是否处于同一个网段：网络号是否相同        
               
       DNS: 域名解析 www.baidu.com   119.75.218.77
    作业：什么叫大端模式，什么小端模式，如何编程验证？
               		
	    					
	    					











