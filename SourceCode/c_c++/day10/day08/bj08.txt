回顾：
     察看多进程  ps -elf
     创建多进程
    	 1)fork()
    	 2) vfork() + excl
     系统中进程的创建是有顺序的， 父子进程的概念
     如果父进程先结束，子进程变成孤儿进程被1号进程收养
     如果子进程先结束，子进程会给父进程发送信号，如果父进程没有处理该信号，子进程会变成僵尸进程 （Z），直到父进程处理了该信号或者父进程结束。
     子进程复制了除代码段外的所有段，和父进程共享代码段。
     fork()函数返回两次
     父进程在fork（）之前定义的全局变量 局部变量在子进程也有同样的一份
     父进程中打开的文件，子进程中复制描述符，不复制文件表。
     文件锁机制父子进程间不具有继承属性。
     进程如何退出？
        1）正常退出
            main 函数中的return 
            exit() _exit() _Exit()
            atexit()向系统注册一系列函数，当进程退出时由操作系统调用
        2）非正常退出
     父进程如何获取子进程的退出状态和退出码？
         wait(...):等待任意子进程退出
         waitpid(...):等待特定子进程退出，可等可不等
         两个宏
             WIFEXITED（...）：判断进程是否正常退出
             WEXITSTATUS(...):	获取退出码
   
  ATM综合案例：
      第一版：不使用多进程 ， Ｃ + 文件操作 
      第二版：使用多进程机制  
  林锐 《高质量的Ｃ/C++编程》
----------------------------------------------------------
1、vfork + excl
   vfork和fork在语法上没有区别，唯一的区别在于vfork不复制父进程的任何资源，而是直接占用父进程运行资源，父进程处于阻塞状态，直到子进程结束或者调用了exec系列函数。
   子进程的结束：使用exit() 或者_exit()
   vfork.c
   
   exec是一系列的函数,用全新的程序替换当前进程中的代码段 数据段、堆区栈区，保留原进程的PID
   execl(...)
   execv(...)
   execle(...)
   execve(...)
   execlp(...)
   execvp(...)
   前4个字符统一为exec
   第5个字符取值： l,list   参数传递为逐个列举的方式
                   v,vector 参数传递为构造指针数组方式
   第6个字符取值： e,（environ）可传递新进程传递环境变量表 
                   p, （path）可执行文件查找方式为文件名
   exec.c
   vfork + exec 的使用： exec2.c
   用途：
      1）直接编程调用系统中提供的可执行命令
      2）降低了模块之间的耦合度
   缺点：以上用法去调用系统命令时会有些一系列的问题，
         例如通配符问题，重定向问题。。。
        execl("bash", "bash", "-c", "ls *.c >a.txt", NULL)
        
   system(...):
        用shell来调用程序=fork+exec+waitpid
        该函数的参考实现，《unix环境高级编程》
      system.c
   对比：system 和 vfork + exec哪个 效率更高？
2、信号
   2.1 信号是用来干什么的？
      用来作进程间异步通信控制，是软件层次上对中断机制的模拟。中断就是让CPU停止正在执行的代码，转而去执行其他的代码，执行完毕后跳回被打断的程序处继续执行的过程。   
  2.2 什么是信号
     信号导致代码中断
        kill -l
         ctrl + c 信号2
         ctrl + \ 信号3
         kill -9 PID 信号9
         段错误     信号11
    unix 系统中信号1~48
    linux系统中信号1~64，但不确保连续
    信号有一个宏名称 以SIG开头，比如说信号2 SIGINT，本质上是一个非负整数。
    注意：在编程时，信号使用宏名称，因为有些系统中信号数字不同，但宏名称相同。
    在linux系统中，1~31的信号是不可靠信号，它们是早期信号，不支持排队，因此可能会丢失。
    34~64是可靠信号，支持排队，不会丢失。
   2.3 信号是如何产生的？
      1）键盘发送 (部分信号)
          ctrl + c
          ctrl + \
      2）程序错误导致 （部分信号）
         段错误
         除0错误
      3） kill 命令 （所有信号）
          kill -信号  进程PID
          system("kill -9 1234")
      4） 系统函数 （所有信号）
   2.4 信号是如何处理的？
      1）默认处理，系统提供的处理方式，多半是退出进程
      2）忽略该信号
      3）自定义处理方式
      注意：有些信号是不能被自定义或者忽略方式来处理的，
     比如说信号9
     进程可以给其他进程发信号， system("kill -9 1")
     但是只能给本用户的进程发信号。
     root用户可以给所有用户进程发信号。
  2.5 信号相关API
     2.5.1安装信号处理函数
        函数signal()/sigaction(),可以用来处理信号的处理方式
          
      signal(int signum, void (*)(int)handler )
           signum ,要捕获的信号
           参数二，可以是以下三个值：
                SIG_IGN
                SIG_DFL
                自定义函数 
           返回值：成功返回之前的处理方式，失败返回SIG_ERR
      signal.c
      复习：函数指针变量的使用
            func_pointer.c
      概念：回调函数 勾子函数
            可重入函数
      练习：signal.c基础上完成ctrl + \的处理
            signal(...) : 自定义函数
                          SIG_IGN
                          SIG_DFL
            将SIGKILL 按照自定义函数
                          SIG_IGN
                          SIG_DFL        
            结论： 信号SIGKILL/SIGSTOP
                   不能忽略也不能被自定义处理
     问题：父子进程间的信号处理？
         如果父进程设置SIGINT信号去调用fa() ,signal(2,fa)
         再执行 fork()
         那么子进程收到SIGINT,该信号会被如何处理？
         如果fork创建了子进程，子进程和父进程的信号处理方式完全一致
    作业： vfork + excl创建的子进程，该子进程的信号处理凡是和父进程的信号处理方式有什么关系？     
         
    
    
    
    
    
    
    
    
    
    
    
    
     
            
   
  
  
     
     
     
     
     
     
     
     
     
     
     
     
     
     
