回顾
    1、mmap来映射文件到内存
       flag参数：如果映射文件 MAP_SHARED
                 如果映射内存空间 MAP_PRIVATE|MAP_ANONYMOUS
       struct stu
       {
       		int age;
       		char name[20];
       };
    2、目录操作
       opendir
       readdir
       closedir
-----------------------------------------------------------
1、多进程编程
   为什么引入多进程
   ps -elf
   系统启动0进程，由0号启动1号进程(/sbin/init),由1号进程再去启动其它的进程
   父子进程的概念
   每个进程都有一个PID，非负整数
2 如何创建子进程
   1）fork()
   2) vfork + excl
2.1 fork
    pid_t fork(void)
    复制父进程的内存空间，复制除了代码段之外的所有区域，代码段父子进程共享
    fork.c
    fork()返回两次，在父进程中执行fork（）的return返回子进程的PID，在子进程中执行fork()的return返回0
    注意： fork()之后先执行父进程还是子进程不确定。
    fork1.c
    fork（）之前的代码只有父进程执行，fork()之后的代码父子进程都有机会执行，受代码逻辑的控制而进入不同的分支。
    fork2.c	
    
    问题：fork_test.c  对应的a.out执行会开始多少个进程？
    fork()创建子进程时，会复制除代码区之外的所有区域，包括缓冲区。子进程中创建的变量父进程不能使用。
    fork3.c
    fork()创建子进程时， 如果父进程有文件描述符，子进程会复制文件描述符，不复制文件表，共用一个文件表（offset）
    fork4.c
    父进程先于子进程结束，子进程变成孤儿进程，该孤儿进程被1号进程收养。
    fork5.c
    如果子进程结束时给父进程的信号没有被及时处理，子进程将变成僵尸进程，直到父进程处理了该信号或者父进程退出.
    fork6.c
3 进程的退出
     main()
     {
     		...
     		return 0 ; return -1;//交给它的父进程
     }    
  3.1正常退出
  	1）在main()函数中执行return语句
  	2）exit()函数退出进程
  	3）_exit()或者 _Exit()
  	4) 最后一个线程退出
  	5）主线程退出
  3.2非正常退出  
     1）被信号打断导致退出 ，如:ctrl + c
     2) 进程中最后一个线程被取消
  3.3 eixt() _exit() _Exit()
      1)_exit() 和_Exit()作用是一样的，区别在于头文件不同
         uc       c函数    
      2）_e(E)xit()是立即使进程退出
         exit()不是立即退出，可以调用执行一些其他函数后再退
         出
         可以使用atexit()函数注册一系列函数，这些函数在exit()退出进程之前被自动调用,如果在main中通过return 返回也会调用这些函数
		   exit.c
		  注意： exit(n)中的n至不能超过255  
	3.4 取得子进程的退出状态和退出码
			wait() 和waitpid()可以让父进程等待子进程结束，并取得子进程的退出状态和退出码（return 后面的值或者exit(n)中的n）
	   3.4.1 wait()
	      等待任意一个子进程结束后就返回
	      pid_t wait(int *status)
	         status是一个传出参数，用来带回结束子进程的退出状态和退出码
	         返回值，有结束子进程就返回结束子进程的PID，
	                 如果该父进程的子进程没有一个结束，阻塞等待，直到等到有子进程结束它才返回
	                 出错返回-1， errno ECHILD
	      wait.c
	   WIFEXITED（stauts）: 判断进程是否正常结束（exit 
	                        return _exit _Exit）
	                         如果是正常结束运算结果为真，
	                         反之为假  
	   WEXITSTATUS（status）: 取得退出码
	    
	   3.4.2 waitpid()
	       选择等待某个特定的子进程结束才返回，也可以选择等待或者不等待
	    pid_t waitpid(pid_t pid, int *status, int option)
	        pid 等待特定的子进程
	           >0,等待特定子进程
	           -1，等待任意子进程 ，等效于wait()
	           <-1, 等待进程组ID等于pid绝对值的任意子进程
	            0，等待其组ID等于调用进程组ID的任意子进程
	        status,
	        option,
	           0, 阻塞，等待的子进程未结束不返回
	           WNOHANG: 不阻塞，如果等待的子进程未结束立刻返
	                    回0
	      waitpid.c
	     练习： 在现有程序基础上waipid等待子进程二结束
	            采用参数为WNOHANG
-----------------------------------------------------------
综合案例一： 银行ATM机的模拟
    ATM功能： 开户 销户 存钱 取钱 查询 转帐
      开户流程：
          一个main()
          .h 文件， 账户信息 : 帐号ID（唯一性）
                               账户名称
                               密码
                               金额
          在main() 函数中应该提供一个操作界面，让用户选择6个功能中的哪个 。假如选择了开户功能，再提供子界面，要求用户输入姓名，密码 ，金额，账户ID后台生成，将以上信息存储到账户信息对应的结构体，将该信息存入文件中去。
      建议： 一个账户一个文件，文件名如何选择，使用ID
      
      查询功能： 登陆验证，要求用户输入帐号ID，密码
                读相应的文件，验证密码是否正确
                如果正确返回（显示）帐号中的金额
      如何解决账户ID不重复？
          先创建一个文件，存入初始（10000），然后每次开账户时，都先读出这个整数，然后整数++做账户ID，同时把+1后的值存回文件中。   
      
      如果在主操作界面中用户选择了某功能，开启一个子进程来完成该功能的实现    
          
                 
             










	       
     
     
    
    	    
   
   
   
   
   
   
   
   
   
   
   









    
    
    
    
    
    
    
    
